set guifont=Andale_Mono:h16,Menlo:h16,Consolas:h16,Courier_New:h16
set wrap
set rnu!
set ignorecase
set hlsearch
set nospell
set autowrite                       " Automatically write a file when leaving a modified buffer
set autowriteall
set autoread
set go-=m
set ts=2
set sw=2
set softtabstop=2               " Let backspace delete indent
set fileencodings=utf-8,gbk,gb18030,gk2312
set isk-=-
set isk-=#
set isk-=.

if has('win32')
    au GUIEnter * simalt ~x
else
    au GUIEnter * call MaximizeWindow()
endif

" 窗口最大化
function! MaximizeWindow()
    silent !wmctrl -r :ACTIVE: -b add,maximized_vert,maximized_horz
endfunction 


"nmap <c-v> p
" rg
if executable('rg')
    set grepprg=rg\ --color=never\ --vimgrep\ --no-heading
    set grepformat=%f:%l:%c:%m,%f:%l:%m
    let g:ctrlp_user_command.fallback = 'rg %s --files --color=never --glob ""'
    let g:ctrlp_use_caching = 0
    let g:ackprg = 'rg --vimgrep --no-heading'
endif

" session.vim
if isdirectory(expand("~/.vim/bundle/vim-session/"))
  let g:session_autosave ='yes'
  let g:session_autoload ='no'
  let g:session_autosave_silent =1
  let g:session_command_aliases = 1
endif


" .spf13-vim-3/.vim/bundle/vim-coloresque/after/syntax/css/
"  gg125

" 菜单配置

let g:ssData = { "menuData": { "data": {}, "list": [] } }
function! s:addMenuData(id, name, key, command) 
  let s:_list = g:ssData.menuData.list
  let s:_data = g:ssData.menuData.data
  call add(s:_list, a:id)
  let s:_data[a:id] = {'name': a:name, 'key': a:key, "command": a:command, 'num': 0}
endfunction

call s:addMenuData('0', "打开当前目录", 'e', '!start explorer %:p:h')
call s:addMenuData('1', "打开cmd", 'c', '!start cmd')
call s:addMenuData('2', "切换目录cd", '2', 'cd %:p:h')
call s:addMenuData('3', "切换目录lcd", '3', 'lcd %:p:h')
call s:addMenuData('4', "powershell", 'p', '!start Powershell')
call s:addMenuData('5', "marks", 'm', "marks|let __inputtag = nr2char(getchar())|redraw|exe \"normal '\".__inputtag")
call s:addMenuData('6', "Session", 'l', "SessionOpen")

"if filereadable(expand("~/.spf13-vim-3/ssData"))
  "so ~/.spf13-vim-3/ssData
"endif
  "let g:ssData = json_decode(join(readfile('~/.spf13-vim-3/ssData'), ''))
  " 自动写入数据
  "function! SSDataInput()
    "call writefile([json_encode(g:ssData)], './.spf13-vim-3/ssData')
  "endfunction
  "autocmd VimLeavePre * call SSDataInput()

if exists('ssData')
  function! SSMenu(data, idList)
    let s:_cmd = ""
    let s:_data = a:data
    let s:_idlist = sort(copy(a:idList), "Compare_")
    let s:_inputList = map(copy(s:_idlist), {key, val -> ' ' . get(s:_data, val).key . ' || ' . get(s:_data, val).name . ' ('  . get(s:_data, val).command . ')--'. get(s:_data, val).num})
    echo join(s:_inputList, "\n")."\n"
    let s:_cmd = nr2char(getchar())
    for item in s:_idlist
      if s:_data[item].key == s:_cmd
        let s:__com = s:_data[item].command
        let s:_data[item].num+=1
        exe s:__com
        :redraw
      endif
    endfor
  endfunction
  function! Compare_(i1, i2) abort
    return get(s:_data, a:i1).num - get(s:_data, a:i2).num
  endfunction

  map <leader>s :call SSMenu(g:ssData.menuData.data, g:ssData.menuData.list)<CR>
endif
if isdirectory(expand("~/.vim/bundle/sessionman.vim/"))
  unmap <leader>ss
  unmap <leader>sl
  unmap <leader>sc
endif
cunmap w!!
":map <F4> [I:let nr = input("Which one: ")<Bar>exe "normal " . nr ."[\t"<CR>
imap <c-v> <c-r>+
cmap <c-v> <c-r>+
map <leader>j <C-W>j
map <leader>k <C-W>k
map <leader>h <C-W>h
map <leader>l <C-W>l
map <leader>x :q<CR>
map <leader>o <C-W>o
map <leader>- <C-W>_<C-W>\|
unmap <leader>jt
cunmap cwd
cunmap cd.
unmap <leader>ew
unmap <leader>es
unmap <leader>ev
unmap <leader>et
map Q :q<CR>
nnoremap <silent> <leader>gd :Gdiff<CR>
map <leader>r <ESC>:CtrlPMRUFiles<CR>
map W :w<CR>
" tags
" set tags=tags;  " ; 不可省略，表示若当前目录中不存在tags， 则在父目录中寻找。
map <C-F12> :!ctags -R --exclude=node_modules --c++-kinds=+p --fields=+iaS --extra=+q .<CR> 

" ctrlp
let g:ctrlp_working_path_mode = 'a'
let g:ctrlp_custom_ignore = {
            \ 'dir':  '\.git$\|\.hg$\|\.svn$\|\.idea$',
            \ 'file': '\.exe$\|\.so$\|\.dll$\|\.pyc$' }
